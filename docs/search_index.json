[["index.html", "Final Project-Group 04 Objective of the Project Dataset Applied Model", " Final Project-Group 04 Shakib-241001661,Shudeshna-241000261,Mithun-241002261,Pradipto-241002161,Mufrad-241001461,Shahriar Islam-241000461 2024-06-29 Objective of the Project perform Regression &amp; Time Series analysis and forecasting techniques on Bitcoin historical price. The experience can be replicated to forecast Stock price &amp; Currency price as well. install.packages(&quot;bookdown&quot;) # or the development version # devtools::install_github(&quot;rstudio/bookdown&quot;) Dataset A dataset of Bitcoin (BTC) historical price against USD. This is a monthly average price dataset having prices from 01 January 2015 to 30 November 2023. Applied Model Linear regression model Quadratic regression model ARMIA model "],["intro.html", "Chapter 1 Data Preprocessing/Cleaning Loading the Dataset Check the data types of the features. Assign appropriate data type to features. Check the structure of the data frame. Check if there’s any missing value. If yes, treat missing values through appropriate methodology.", " Chapter 1 Data Preprocessing/Cleaning Loading the Dataset Load the dataset from csv into a data frame named BitCoin. Check the data types of the features. Assign appropriate data type to features. Check the structure of the data frame. Check if there’s any missing value. If yes, treat missing values through appropriate methodology. Load the dataset from csv into a data frame named BitCoin. #(&quot;tidyverse&quot;) #Load the dataset from csv into a data frame named BitCoin. library(tidyverse) ## ── Attaching core tidyverse packages ─── ## ✔ dplyr 1.1.4 ✔ readr 2.1.5 ## ✔ forcats 1.0.0 ✔ stringr 1.5.1 ## ✔ ggplot2 3.5.1 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.3 ✔ tidyr 1.3.1 ## ✔ purrr 1.0.2 ## ── Conflicts ── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors #load csv from github(uploaded for Assignment_02_Group_04) bitcoin &lt;- read.csv(&quot;https://raw.githubusercontent.com/shakibed/Final_Project_Group_04/main/BTC-Monthly.csv&quot;, stringsAsFactors = FALSE) view(bitcoin) Check the data types of the features. #Check the data types of the features. glimpse(bitcoin) ## Rows: 107 ## Columns: 2 ## $ Date &lt;chr&gt; &quot;2015-01-01&quot;, &quot;2015-02-01&quot;, &quot;2015-03-01&quot;, &quot;2015-04-01&quot;, &quot;2015-05… ## $ Close &lt;dbl&gt; 217.464, 254.263, 244.224, 236.145, 230.190, 263.072, 284.650, 2… Code explanation here We checked the data types using glimpse(bitcoin) and found we have two columns in data set. We need to convert the Date column from chr (character) type to Date type because our target is to work with a time series object or perform linear regression analysis. Assign appropriate data type to features. bitcoin$Date &lt;- as.Date(bitcoin$Date) glimpse(bitcoin) ## Rows: 107 ## Columns: 2 ## $ Date &lt;date&gt; 2015-01-01, 2015-02-01, 2015-03-01, 2015-04-01, 2015-05-01, 201… ## $ Close &lt;dbl&gt; 217.464, 254.263, 244.224, 236.145, 230.190, 263.072, 284.650, 2… Code explanation here This will allow us to properly utilize the Date column in time series analysis or linear regression models. Check the structure of the data frame. #Check the data types of the features. str(bitcoin) ## &#39;data.frame&#39;: 107 obs. of 2 variables: ## $ Date : Date, format: &quot;2015-01-01&quot; &quot;2015-02-01&quot; ... ## $ Close: num 217 254 244 236 230 ... Code explanation here We checked the structure of the data frame using str(bitcoin) and found the following: The Date column is already in the Date format, and the Close column is of type num (numeric). Since the Date column is correctly formatted as a date, it is ready for time series analysis or linear regression models without any further modification. Check if there’s any missing value. If yes, treat missing values through appropriate methodology. #Check if there’s any missing value. If yes, treat missing values through appropriate methodology colSums(is.na(bitcoin)) ## Date Close ## 0 0 #it shows no missing value found Code explanation here We checked for missing values in the bitcoin data frame using colSums(is.na(bitcoin)) and found the following: This indicates that there are no missing values in either the Date or Close columns. Since there are no missing values, no further action is needed to treat missing values. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 1.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa "],["descriptive-analytics.html", "Chapter 2 Descriptive Analytics Create a monthly boxplot of prices. Create a yearly boxplot of prices. Create year wise trend lines of prices. Find the relationship between consecutive months. Show the correlation through a scatter plot.", " Chapter 2 Descriptive Analytics Copy the BitCoin data frame to a new data frame named BitCoin_df. In the new data frame create two more columns ‘month’ &amp; ‘year’ by populating with the months &amp; years values from the ‘Date’ column. Create a monthly boxplot of prices. Create a yearly boxplot of prices. Create year wise trend lines of prices. – Convert the BitCoin data frame to a time series object with frequency 1. Plot the time series of monthly prices on years. Use blue color dots to plot the data points. Connect the points with a line. Find the relationship between consecutive Months. Show the correlation through a scatter plot. Create a monthly boxplot of prices. # 1. Create a monthly boxplot of prices ggplot(BitCoin_df, aes(x = factor(month), y = Close, fill = factor(month))) + geom_boxplot(outlier.colour = &quot;red&quot;) + labs(title = &quot;Monthly Boxplot of Bitcoin Prices&quot;, x = &quot;Month&quot;, y = &quot;Close Price&quot;) + scale_fill_viridis_d(name = &quot;Month&quot;, labels = month.abb) Code explanation here The boxplot shows that Bitcoin prices exhibit some level of seasonal variation. Prices tend to be higher during certain months (March, April, May) compared to others ( June, July). This could indicate seasonal trends or cycles in the market. The presence of outliers (red dots) in some months, especially in May and September, indicates that there were extreme price changes during these periods. Create a yearly boxplot of prices. library(RColorBrewer) # 2. Create a yearly boxplot of prices color_palette &lt;- brewer.pal(9, &quot;Set3&quot;) # 9 colors for 9 years #the boxplot with a legend for the years ggplot(BitCoin_df, aes(x = factor(year), y = Close, fill = factor(year))) + geom_boxplot(outlier.colour = &quot;red&quot;) + labs(title = &quot;Yearly Boxplot of Bitcoin Prices&quot;, x = &quot;Year&quot;, y = &quot;Close Price&quot;) + scale_fill_manual(name = &quot;Year&quot;, values = setNames(color_palette, as.character(2015:2023))) + theme(legend.position = &quot;right&quot;) Code explanation here A boxplot showing the distribution of Bitcoin closing prices over different years. Each box represents the interquartile range (IQR) of the closing prices for a particular year, with the horizontal line inside the box indicating the median price. T he whiskers extend to the minimum and maximum values within 1.5 times the IQR from the first and third quartiles, respectively. Outliers beyond this range are shown as individual points. Create year wise trend lines of prices. # 3. Create year-wise trend lines of prices ggplot(BitCoin_df, aes(x = Date, y = Close, color = year)) + geom_line() + labs(title = &quot;Year-Wise Trend Lines of Bitcoin Prices&quot;, x = &quot;Date&quot;, y = &quot;Close Price&quot;) + theme(legend.position = &quot;bottom&quot;) Explanation of Plot A trend line showing the price of Bitcoin changes over different years. 2015,2016: Bitcoin prices were relatively low and stable, with prices mostly below $1,000. 2017: Significant growth was observed, with prices starting below $1,000 and rising to nearly $20,000 by the end of the year. 2018,2019: After the peak in 2017, prices dropped significantly, fluctuating between $3,000 and $10,000.Prices started to recover, stabilizing between $3,000 and $12,000. 2020: There was a steady increase, with prices rising from around $5,000 to over $30,000 by the end of the year. 2021: Marked a dramatic rise, with Bitcoin prices reaching new all-time highs, peaking around $60,000. 2022: Prices were highly volatile, with significant drops and recoveries, ranging from $30,000 to $50,000. 2023: Prices appeared to stabilize somewhat, fluctuating between $20,000 and $40,000. Convert the BitCoin data frame to a time series object with frequency 1 # Convert the BitCoin data frame to a time series object with frequency 1 bitcoin_ts &lt;- ts(BitCoin_df$Close, start = c(as.numeric(format(min(BitCoin_df$Date), &quot;%Y&quot;)), 1), frequency = 1) # Print the time series object print(bitcoin_ts) ## Time Series: ## Start = 2015 ## End = 2121 ## Frequency = 1 ## [1] 217.464 254.263 244.224 236.145 230.190 263.072 284.650 ## [8] 230.056 236.060 314.166 377.321 430.567 368.767 437.697 ## [15] 416.729 448.318 531.386 673.337 624.681 575.472 609.735 ## [22] 700.972 745.691 963.743 970.403 1179.970 1071.790 1347.890 ## [29] 2286.410 2480.840 2875.340 4703.390 4338.710 6468.400 10233.600 ## [36] 14156.400 10221.100 10397.900 6973.530 9240.550 7494.170 6404.000 ## [43] 7780.440 7037.580 6625.560 6317.610 4017.269 3742.700 3457.793 ## [50] 3854.785 4105.404 5350.727 8574.502 10817.155 10085.628 9630.664 ## [57] 8293.868 9199.585 7569.630 7193.599 9350.529 8599.509 6438.645 ## [64] 8658.554 9461.059 9137.993 11323.467 11680.820 10784.491 13780.995 ## [71] 19625.836 29001.721 33114.359 45137.770 58918.832 57750.176 37332.855 ## [78] 35040.836 41626.195 47166.688 43790.895 61318.957 57005.426 46306.445 ## [85] 38483.125 43193.234 45538.676 37714.875 31792.311 19784.727 23336.896 ## [92] 20049.764 19431.789 20495.773 17168.566 16547.496 23139.283 23147.354 ## [99] 28478.484 29268.807 27219.658 30477.252 29230.111 25931.473 26967.916 ## [106] 34667.781 37712.746 Plot the time series of monthly prices on years. Use blue color dots to plot the data points. Connect the points with a line. # Plot the time series of monthly prices on years ggplot(BitCoin_df, aes(x = Date, y = Close)) + geom_point(color = &quot;blue&quot;) + # Blue color dots for data points geom_line(color = &quot;blue&quot;) + # Connect the points with a line labs(title = &quot;Time Series of Monthly Bitcoin Prices&quot;, x = &quot;Year&quot;, y = &quot;Close Price&quot;) + theme_minimal() Explanation of Plot Explanation of the Plot: Horizontal Axis (Year): Represents the timeline from 2016 to 2024. Vertical Axis (Close Price): Represents the closing price of Bitcoin at the end of each month. Blue Dots: Each dot represents the closing price of Bitcoin for a particular month. Blue Line: Connects the dots to show the trend and continuity of Bitcoin prices over time. The plot provides a visual representation of Bitcoin’s price volatility and trends, making it easier to analyze patterns and potential factors affecting its value over the given period. Result The plot reveals significant fluctuations in Bitcoin prices, including notable peaks around 2021 and subsequent declines. The most recent data indicates a rising trend in prices again. Find the relationship between consecutive months. Show the correlation through a scatter plot. library(dplyr) library(ggplot2) library(lubridate) # Aggregate the data by month BitCoin_df_monthly &lt;- BitCoin_df %&gt;% mutate(YearMonth = floor_date(Date, &quot;month&quot;)) %&gt;% group_by(YearMonth) %&gt;% summarise(Monthly_Close = last(Close)) %&gt;% arrange(YearMonth) # Create a new column for the previous month&#39;s closing price BitCoin_df_monthly &lt;- BitCoin_df_monthly %&gt;% mutate(Prev_Month_Close = lag(Monthly_Close, 1)) # Remove the first row with NA value in Prev_Month_Close BitCoin_df_monthly &lt;- BitCoin_df_monthly %&gt;% filter(!is.na(Prev_Month_Close)) # Calculate the correlation monthly_correlation &lt;- cor(BitCoin_df_monthly$Monthly_Close, BitCoin_df_monthly$Prev_Month_Close) print(paste(&quot;Correlation between consecutive months: &quot;, monthly_correlation)) ## [1] &quot;Correlation between consecutive months: 0.961776393506846&quot; # Create a scatter plot ggplot(BitCoin_df_monthly, aes(x = Prev_Month_Close, y = Monthly_Close)) + geom_point(color = &quot;blue&quot;) + labs(title = &quot;Scatter Plot of Consecutive Month Prices&quot;, subtitle = paste(&quot;Correlation: &quot;, round(monthly_correlation, 2)), x = &quot;Previous Month Close Price&quot;, y = &quot;Current Month Close Price&quot;) + theme_minimal() Code explanation here The scatter plot provides a clear visual representation of the relationship between Bitcoin prices in consecutive months, highlighting the strong correlation 0.96 and linear trend, which are valuable for analyses and decision-making processes. Horizontal Axis (Previous Month Close Price): Represents the closing price of Bitcoin for the previous month. Vertical Axis (Current Month Close Price): Represents the closing price of Bitcoin for the current month. Blue Dots: Each dot represents the closing price of Bitcoin for a specific month plotted against the closing price of the previous month. Correlation Value: Displayed at the top of the chart, it quantifies the strength of the relationship between - consecutive month’s prices. "],["regression-analysis.html", "Chapter 3 Regression Analysis", " Chapter 3 Regression Analysis 3.0.1 Linear Regression Create a linear model of the time series dataset. Show the summary of the model and explain the outcome. Create a plot of the linear model on top of the time series dataset line plot with scatter data points. Perform residual analysis and create a line &amp; scatter plot of the residuals. Explain the outcome. Create a histogram plot of the residuals. Explain the outcome. Create ACF &amp; PACF plots of residuals. Explain the outcome. Create QQ plot of residuals. Explain the outcome. Perform Shapiro-Wilk test on residuals. Explain the outcome. Explain if linear model is appropriate or not. 3.0.1.1 Create a linear model of the time series dataset. # Convert Date to numeric format for linear modeling BitCoin_df &lt;- BitCoin_df %&gt;% mutate(Date_numeric = as.numeric(Date)) # Fit the linear model linear_model &lt;- lm(Close ~ Date_numeric, data = BitCoin_df) #y=mx+c #close price = m*numeric date + c Code explanation here The linear model predicts Bitcoin’s closing price based on the date. The slope shows the price change rate over time, and the intercept represents the initial price at the start date. 3.0.1.2 Show the summary of the model and explain the outcome. summary(linear_model) ## ## Call: ## lm(formula = Close ~ Date_numeric, data = BitCoin_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -15114 -7997 -2255 3065 35626 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -2.211e+05 1.939e+04 -11.40 &lt;2e-16 *** ## Date_numeric 1.308e+01 1.073e+00 12.19 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 10430 on 105 degrees of freedom ## Multiple R-squared: 0.586, Adjusted R-squared: 0.5821 ## F-statistic: 148.6 on 1 and 105 DF, p-value: &lt; 2.2e-16 In Summary The model indicates a statistically significant relationship between the date and the closing price of Bitcoin, as shown by the very small p-value (&lt; 2.2e-16). The date explains about 58.6% of the variation in closing prices, as reflected by the Multiple R-squared and Adjusted R-squared values. The average prediction error is approximately 10430, as indicated by the Residual Standard Error. For each unit increase in the numeric date, the closing price of Bitcoin rises by about 13.08 units, which is determined by the slope of the regression line. # Create a new column with fitted values BitCoin_df &lt;- BitCoin_df %&gt;% mutate(Fitted_Close = predict(linear_model)) # Plot the original data and the linear model ggplot(BitCoin_df, aes(x = Date)) + geom_point(aes(y = Close, color = &quot;Original Data&quot;)) + # Original data points geom_line(aes(y = Fitted_Close, color = &quot;Fitted Line&quot;)) + # Fitted line labs(title = &quot;Linear Model of Bitcoin Prices Over Time&quot;, x = &quot;Date&quot;, y = &quot;Close Price&quot;, color = &quot;Legend&quot;) + # Add a label to the legend theme_minimal() + scale_color_manual(values = c(&quot;Original Data&quot; = &quot;blue&quot;, &quot;Fitted Line&quot; = &quot;red&quot;)) # Specify colors Code explanation here The provided graph and summary show a linear regression model of Bitcoin prices over time. The blue points represent the original data, while the red line represents the fitted linear model. 3.0.1.3 Create a plot of the linear model on top of the time series dataset line plot with scatter data points. #Create a plot of the linear model on top of the time series dataset line plot with scatter data points. #Plot the original data, the time series line, and the linear model ggplot(BitCoin_df, aes(x = Date)) + geom_point(aes(y = Close), color = &quot;blue&quot;) + # Original data points geom_line(aes(y = Close), color = &quot;blue&quot;, linetype = &quot;dashed&quot;) + # Time series line geom_line(aes(y = Fitted_Close), color = &quot;red&quot;) + # Fitted linear model line labs(title = &quot;Time Series of Bitcoin Prices with Linear Model&quot;, x = &quot;Date&quot;, y = &quot;Close Price&quot;) + theme_minimal() Code explanation here The graph shows Bitcoin prices over time with blue dots representing the original data points and a blue dashed line representing the time series trend. The red line indicates the fitted linear model. The linear model captures the general upward trend but misses some of the more volatile fluctuations in Bitcoin prices. 3.0.1.4 Perform residual analysis #Calculate residuals BitCoin_df &lt;- BitCoin_df %&gt;% mutate(Residuals = Close - Fitted_Close) #residual calcultion in different way #res_dual_values &lt;- residuals(linear_model) #summary(res_dual_values) Code explanation here Residuals are calculated to assess model fit. The dataset includes date, closing price, month, year, numeric date, fitted close values, and residuals for verification. 3.0.1.5 Perform residual analysis and create a line &amp; scatter plot of the # Plot the residuals: Line plot ggplot(BitCoin_df, aes(x = Date, y = Residuals)) + geom_line(color = &quot;blue&quot;) + labs(title = &quot;Line Plot of Residuals over Time&quot;, x = &quot;Date&quot;, y = &quot;Residuals&quot;) + theme_minimal() Code explanation here The graph shows a blue line plotting the difference between actual values and predicted values for a Bitcoin data set, over time. Basically, it shows how much the actual Bitcoin values differed from what a model predicted on certain dates. 3.0.1.6 Residual analysis scatter plot # Plot the residuals: Scatter plot ggplot(BitCoin_df, aes(x = Fitted_Close, y = Residuals)) + geom_point(color = &quot;blue&quot;) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + labs(title = &quot;Scatter Plot of Residuals&quot;, x = &quot;Fitted Close Price&quot;, y = &quot;Residuals&quot;) + theme_minimal() Code explanation here This graph shows blue dots representing the difference between actual Bitcoin closing prices and what a model predicted. The horizontal red line represents perfect predictions (no difference). Scattered points around the line indicate the model’s accuracy - ideally, the dots would be random with no clear pattern. 3.0.1.7 Summary of Residual analysis # Summary statistics of the residuals summary(BitCoin_df$Residuals) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -15114 -7997 -2255 0 3065 35626 Code explanation here The summary statistics of the residuals provide insight into the accuracy of the linear model’s predictions for Bitcoin closing prices. The residuals range from -15,114 to 35,626, indicating the model sometimes significantly underestimates or overestimates the actual prices. The median residual of -2,255 suggests that half of the predictions are off by less than this amount. The mean residual is 0, indicating that, on average, the model’s predictions are unbiased. The first and third quartiles (-7,997 and 3,065) show that 50% of the residuals fall within this range, highlighting the variability in prediction accuracy. 3.0.1.8 Create a histogram plot of the residuals. Explain the outcome. #Create a histogram plot of the residuals. Explain the outcome. # Plot the histogram of residuals ggplot(BitCoin_df, aes(x = Residuals)) + geom_histogram(binwidth = 500, color = &quot;black&quot;, fill = &quot;blue&quot;, alpha = 0.7) + labs(title = &quot;Histogram of Residuals&quot;, x = &quot;Residuals&quot;, y = &quot;Frequency&quot;) + theme_minimal() Code explanation here Ideally, the residuals should be normally distributed (bell-shaped curve centered around zero). The histogram here shows some deviation from normality, indicating that the model may not perfectly capture the data distribution. 3.0.1.9 Create a histogram plot of the residuals with # Overlay a normal distribution curve on the histogram ggplot(BitCoin_df, aes(x = Residuals)) + geom_histogram(aes(y = ..density..), binwidth = 500, color = &quot;black&quot;, fill = &quot;blue&quot;, alpha = 0.7) + stat_function(fun = dnorm, args = list(mean = mean(BitCoin_df$Residuals), sd = sd(BitCoin_df$Residuals)), color = &quot;red&quot;, size = 1) + labs(title = &quot;Histogram of Residuals with Normal Curve&quot;, x = &quot;Residuals&quot;, y = &quot;Density&quot;) + theme_minimal() ## Warning: Using `size` aesthetic for lines was ## deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 ## hours. ## Call ## `lifecycle::last_lifecycle_warnings()` ## to see where this warning was ## generated. ## Warning: The dot-dot notation (`..density..`) ## was deprecated in ggplot2 3.4.0. ## ℹ Please use `after_stat(density)` ## instead. ## This warning is displayed once every 8 ## hours. ## Call ## `lifecycle::last_lifecycle_warnings()` ## to see where this warning was ## generated. code explanation here This graph shows a histogram of prediction errors (residuals) for Bitcoin prices with a normal distribution curve overlaid in red. The bars represent the frequency of errors in different price ranges. Ideally, the bars would closely match the smooth red curve, indicating the errors follow a normal distribution. By comparing their shapes, we can assess how close the actual errors are to being normally distributed. 3.0.1.10 Create ACF &amp; PACF plots of residuals.Explain the outcome. acf(BitCoin_df$Residuals, main = &quot;ACF of Residuals&quot;) Code explanation here In this plot, the residuals have significant autocorrelations up to around lag 5. This suggests that the residuals are not purely random and that there is some pattern left unexplained by the model. pacf(BitCoin_df$Residuals, main = &quot;PACF of Residuals&quot;) In a well-fitted model, the PACF should show no significant partial autocorrelation beyond the first few lags. This plot shows a significant partial autocorrelation at lag 1 and some minor significant lags afterward, suggesting that there might be some remaining structure in the residuals. These analyses suggest that the linear regression model may not be the best fit for this time series data, and a more complex model may be needed to better capture the underlying patterns and trends in Bitcoin prices. 3.0.1.11 Create QQ plot of residuals. Explain the outcome. # QQ plot of residuals qqnorm(BitCoin_df$Residuals) qqline(BitCoin_df$Residuals, col = &quot;red&quot;) Code explanation here The residuals do not follow a normal distribution, as indicated by the significant deviations in the tails. Since many statistical methods (like linear regression) assume normally distributed residuals, the non-normality observed here indicates that the model assumptions are violated. 3.0.1.12 Perform Shapiro-Wilk test on residuals. Explain the outcome. #Perform Shapiro-Wilk test on residuals. Explain the outcome. # Perform Shapiro-Wilk test on residuals shapiro_test &lt;- shapiro.test(BitCoin_df$Residuals) # Print the result of the Shapiro-Wilk test print(shapiro_test) ## ## Shapiro-Wilk normality test ## ## data: BitCoin_df$Residuals ## W = 0.85983, p-value = 1.215e-08 Code explanation here The Shapiro-Wilk test assesses the normality of residuals. The test statistic  W is 0.85983, and the p-value is 1.215e-08, which is much less than 0.05. This indicates that the residuals are not normally distributed, 3.0.1.13 Explain if linear model is appropriate or not. Code explanation here The linear regression model is not a suitable choice for Bitcoin price forecasting. The model explains about 58.6% of the variation in closing Bitcoin prices, as indicated by the Multiple R-squared and Adjusted R-squared values of Linear Model. With some Residual Analysis we also get same indication: ACF test of Residuals: The ACF plot of residuals shows significant autocorrelations up to around lag 5. This suggests that the residuals are not purely random and that some patterns remain unexplained by the model. PACF test of Residuals: In a well-fitted model, the PACF should show no significant partial autocorrelation beyond the first few lags. -The PACF plot shows a significant partial autocorrelation at lag 1 and some minor significant lags afterward, indicating remaining structure in the residuals. QQ Plot: -The QQ plot reveals that the residuals do not follow a normal distribution, as evidenced by significant deviations in the tails. Shapiro-Wilk Test: The Shapiro-Wilk test yields a p-value of 1.215e-08, indicating that the residuals are not normally distributed. The residuals exhibit significant autocorrelation and non-normality, confirming that the linear regression model is not capturing all the patterns in the data. 3.0.2 Quadratic Regression Create a quadratic model of the time series dataset. Show the summary of the model and explain the outcome. Explain if quadratic model is appropriate or not. 3.0.2.1 Create a quadratic model of the time series dataset # Create the quadratic term for the date BitCoin_df &lt;- BitCoin_df %&gt;% mutate(Date_numeric = as.numeric(Date), Date_numeric2 = Date_numeric^2) view(BitCoin_df) # Fit the quadratic model quadratic_model &lt;- lm(Close ~ Date_numeric + Date_numeric2, data = BitCoin_df) Code explanation here The dataset is enhanced by adding a squared numeric date column to capture non-linear trends. A quadratic regression model is then fitted with closing price as the dependent variable and both the numeric date and its square as independent variables. This model aims to better capture the relationship between time and Bitcoin closing prices by accounting for potential quadratic effects. 3.0.2.2 Show the summary of the model and explain the outcome. summary(quadratic_model) ## ## Call: ## lm(formula = Close ~ Date_numeric + Date_numeric2, data = BitCoin_df) ## ## Residuals: ## Min 1Q Median 3Q Max ## -15872 -7420 -1996 2666 36106 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.066e+05 4.157e+05 0.256 0.798 ## Date_numeric -2.333e+01 4.615e+01 -0.506 0.614 ## Date_numeric2 1.009e-03 1.278e-03 0.789 0.432 ## ## Residual standard error: 10450 on 104 degrees of freedom ## Multiple R-squared: 0.5885, Adjusted R-squared: 0.5806 ## F-statistic: 74.36 on 2 and 104 DF, p-value: &lt; 2.2e-16 Code explanation here Coefficients: the coefficients for Date_numeric and Date_numeric^2 are not statistically significant (p-values &gt; 0.05). This suggests that neither the linear nor the quadratic term significantly predicts the closing price of Bitcoin. Model Fit: The R-squared value of 0.5885 indicates that the model explains about 58.85% of the variance in Bitcoin’s closing prices. This is a moderate level of explanation. The significant F-statistic indicates that the model as a whole is statistically significant, even though individual predictors are not. In the context of financial markets and Bitcoin price forecasting, a model explaining 58% of the variance can be seen as relatively decent, given the high volatility and complexity of financial data. 3.0.2.3 Explain if quadratic model is appropriate or not. # Create a new column with the fitted values from the quadratic model BitCoin_df &lt;- BitCoin_df %&gt;% mutate(Fitted_Close_Quadratic = predict(quadratic_model)) # Plot the original data, the linear model, and the quadratic model ggplot(BitCoin_df, aes(x = Date)) + geom_point(aes(y = Close), color = &quot;blue&quot;) + # Original data points geom_line(aes(y = Fitted_Close), color = &quot;red&quot;, linetype = &quot;dashed&quot;) + # Fitted linear model line geom_line(aes(y = Fitted_Close_Quadratic), color = &quot;green&quot;) + # Fitted quadratic model line labs(title = &quot;Time Series of Bitcoin Prices with Linear and Quadratic Models&quot;, x = &quot;Date&quot;, y = &quot;Close Price&quot;) + theme_minimal() summary(BitCoin_df$Fitted_Close_Quadratic) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -4411 4156 14045 14944 25262 37777 Code explanation here The quadratic model shows some ability to explain the variance in Bitcoin’s closing prices, but the lack of significance in the individual coefficients suggests that it might not be the best fit. Additional predictors or a different modeling approach (e.g., non-linear models, time series models) might be needed to better capture the underlying patterns in the data. "],["arima-model.html", "Chapter 4 ARIMA Model 4.1 Create ACF &amp; PACF plots of the time series data set with maximum lag of 24. Explain the outcome and comment on the dataset’s nature. 4.2 Perform ADF test. Explain the outcome. 4.3 Explain if the dataset is stationary or not. 4.4 Create QQ plot &amp; perform Shapiro-Wilk test. 4.5 If the dataset is not stationary, then make it stationary by differencing. Show a plot of the dataset after differencing and perform ADF test on differenced dataset to check stationarity again. 4.6 Perform ACF &amp; PACF test to find the probable model candidates. Explain the outcome of the plots. 4.7 Perform EACF test to comprehensively test the possible candidate models. Mention the models that you have selected for modeling (select at least 3 models). 4.8 Estimate the ARIMA parameters by creating the above selected models. Perform coeftest on each model. Explain the outcome from the level of significance. 4.9 Evaluate the models through AIC &amp; BIC tests. 4.10 From outcome of above two steps select best two models. Explain why you have chosen those two models. 4.11 Assess the chosen two models through accuracy test. 4.12 Create a histogram plot of the residuals of the two models. Explain the outcome. 4.13 Create ACF &amp; PACF plots of residuals of the two models. Explain the outcome. 4.14 Create QQ plot of residuals of the two models. Explain the outcome. 4.15 Perform Shapiro-Wilk test on residuals of the two models. Explain the outcome. 4.16 Select the best model from the above two models using the outcome of all the above analysis. This is going to be your final model.", " Chapter 4 ARIMA Model library(kableExtra) ## ## Attaching package: &#39;kableExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows library(tidyverse) library(forecast) ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo library(tseries) library(lmtest) ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric #load csv from github(uploaded for Assignment_02_Group_04) BitCoin &lt;- read.csv(&quot;https://raw.githubusercontent.com/shakibed/Final_Project_Group_04/main/BTC-Monthly.csv&quot;, stringsAsFactors = FALSE) #convert it to date BitCoin$Date &lt;- as.Date(BitCoin$Date) #it shows no missing value found # Copy the bitcoin data frame to a new data frame named BitCoin_df BitCoin_df&lt;- BitCoin # Create &#39;month&#39; and &#39;year&#39; columns in the BitCoin_df data frame BitCoin_df &lt;- BitCoin_df %&gt;% mutate( month = format(Date, &quot;%m&quot;), year = format(Date, &quot;%Y&quot;) ) # Convert to time series object bitcoin_ts &lt;- ts(BitCoin_df$Close, start = c(as.numeric(format(min(BitCoin_df$Date), &quot;%Y&quot;)), as.numeric(format(min(BitCoin_df$Date), &quot;%m&quot;))), frequency = 12) Create ACF &amp; PACF plots of the time series data set with maximum lag of 24. Explain the outcome and comment on the dataset’s nature. Perform ADF test. Explain the outcome. Explain if the dataset is stationary or not. Create QQ plot &amp; perform Shapiro-Wilk test. If the dataset is not stationary, then make it stationary by differencing. Show a plot of the dataset after differencing and perform ADF test on differenced dataset to check stationarity again. Perform ACF &amp; PACF test to find the probable model candidates. Explain the outcome of the plots. Perform EACF test to comprehensively test the possible candidate models. Mention the models that you have selected for modeling (select at least 3 models). Estimate the ARIMA parameters by creating the above selected models. Perform coeftest on each model. Explain the outcome from the level of significance. Evaluate the models through AIC &amp; BIC tests. From outcome of above two steps select best two models. Explain why you have chosen those two models. Assess the chosen two models through accuracy test. Perform residual analysis of the two models and create line &amp; scatter plot of the residuals. Explain the outcome. Create a histogram plot of the residuals of the two models. Explain the outcome. Create ACF &amp; PACF plots of residuals of the two models. Explain the outcome. Create QQ plot of residuals of the two models. Explain the outcome. Perform Shapiro-Wilk test on residuals of the two models. Explain the outcome. Select the best model from the above two models using the outcome of all the above analysis. This is going to be your final model. 4.1 Create ACF &amp; PACF plots of the time series data set with maximum lag of 24. Explain the outcome and comment on the dataset’s nature. # ACF &amp; PACF plots with maximum lag of 24 acf(bitcoin_ts, lag.max = 24, main = &quot;ACF of Bitcoin Prices&quot;) pacf(bitcoin_ts, lag.max = 24, main = &quot;PACF of Bitcoin Prices&quot;) Explanation of ACF Plot The ACF (Autocorrelation Function) plot provided shows the autocorrelation of Bitcoin prices over different lags up to 24 days. The first few lags show very high autocorrelation, close to 1.0. This indicates that Bitcoin prices are strongly correlated with their recent past values. The autocorrelation values gradually decline as the lag increases. This tells us that the data has a pattern that lasts a while and what happened in the past continues to influence what happens in the future for a longer period. Nature of the Dataset: Non-Stationarity: The high initial autocorrelation and gradual decline suggest that the Bitcoin price series is likely non-stationary. Non-stationary time series often exhibit trends, seasonal patterns, or other forms of long-term dependencies. Trend: The high autocorrelation at lag 1 and significant autocorrelation at subsequent lags imply that the series likely has a trend component. Seasonality: The plot does not clearly indicate strong seasonality, but further investigation might be needed to confirm this. In summary, - We identified data is likely non-stationary with a trend. - Differencing and possibly transformation (e.g., logarithms) might be necessary to stabilize the mean and variance before applying forecasting models. Explanation of PACF Plot The PACF (Partial Autocorrelation Function) plot of Bitcoin prices provides insights into the time series data’s nature, after removing the effects of intervening values. - The PACF at lag 1 is significantly high, close to 0.8. This indicates a strong direct relationship between the current value and its immediate past value. - After lag 1, the partial autocorrelations drop significantly and most of them are within the 95% confidence interval .This implies that differencing the series (likely once, i.e., d=1d=1) may help in achieving stationarity. The PACF does not show significant spikes at higher lags, which suggests that the direct influence of past values decreases quickly after the first lag. Nature of the Dataset: Non-Stationarity:Similar to the ACF plot, the high initial value in the PACF suggests that the series is non-stationary and likely has a trend component. Seasonality: The absence of significant spikes at higher lags suggests that there is no strong seasonality in the dataset. In summary, The PACF plot supports the earlier observation that the Bitcoin price series is non-stationary with a trend and follows an autoregressive process, primarily influenced by its immediate past value. Using differencing to make the series stationary, followed by fitting an ARIMA model, should yield a good forecasting model. The high initial PACF value suggests that an AR(1) term will be significant in the model. 4.2 Perform ADF test. Explain the outcome. # Perform ADF test adf_test &lt;- adf.test(bitcoin_ts) print(adf_test) ## ## Augmented Dickey-Fuller Test ## ## data: bitcoin_ts ## Dickey-Fuller = -2.5743, Lag order = 4, p-value = 0.3385 ## alternative hypothesis: stationary In summary,Augmented Dickey-Fuller Test The Augmented Dickey-Fuller (ADF) test is used to check if a time series is stationary. The time series data is likely not stationary. Since the p-value is greater than 0.05 we fail to reject the null hypothesis. Means time series is non-stationary. differencing might be needed to make it stationary before further analysis. Outcome: - This means that we do not have enough evidence to say that the Bitcoin time series is stationary. 4.3 Explain if the dataset is stationary or not. Based on the results from the ACF, PACF, and Augmented Dickey-Fuller (ADF) tests, we can conclude the following: ACF and PACF Results: ACF: The high autocorrelation at the initial lags and gradual decline suggest a persistent pattern and trend in the data, indicating non-stationarity. PACF: The significant spike at lag 1 and quick drop-off thereafter further support the presence of a trend and non-stationarity. ADF Test Result: p-value = 0.3385: This high p-value indicates that we fail to reject the null hypothesis of the ADF test, suggesting that the Bitcoin price series is non-stationary. Conclusion: Non-Stationary Data: The combined evidence from the ACF, PACF, and ADF tests strongly indicates that the Bitcoin price series is non-stationary and exhibits a trend component. Differencing the series is likely required to achieve stationarity for further analysis and modeling. 4.4 Create QQ plot &amp; perform Shapiro-Wilk test. # Perform QQ plot and Shapiro-Wilk test qqnorm(bitcoin_ts, main = &quot;QQ Plot of Bitcoin Prices&quot;) qqline(bitcoin_ts, col = &quot;red&quot;) shapiro_test &lt;- shapiro.test(bitcoin_ts) print(shapiro_test) ## ## Shapiro-Wilk normality test ## ## data: bitcoin_ts ## W = 0.83358, p-value = 1.258e-09 Code explanation here The Bitcoin prices do not follow a normal distribution. The points on the left side of the plot (lower quantiles) and right side (higher quantiles) deviate significantly from the red line,and the clustering indicate that the data is skewed and has heavier tails than a normal distribution. The points in the middle are somewhat closer to the red line but still show noticeable deviation. This suggests that the central part of the distribution does not perfectly follow a normal distribution. 4.5 If the dataset is not stationary, then make it stationary by differencing. Show a plot of the dataset after differencing and perform ADF test on differenced dataset to check stationarity again. # If the dataset is not stationary, then make it stationary by differencing bitcoin_diff &lt;- diff(bitcoin_ts, differences = 1) # Plot the differenced data plot(bitcoin_diff, main = &quot;Differenced Bitcoin Prices&quot;, ylab = &quot;Differenced Prices&quot;, xlab = &quot;Time&quot;) # Perform ADF test on differenced data adf_test_diff &lt;- adf.test(bitcoin_diff) ## Warning in adf.test(bitcoin_diff): p-value smaller than printed p-value print(adf_test_diff) ## ## Augmented Dickey-Fuller Test ## ## data: bitcoin_diff ## Dickey-Fuller = -5.1599, Lag order = 4, p-value = 0.01 ## alternative hypothesis: stationary Stationarity: - Given a very small p-value (typically less than 0.05) from the ADF test, we reject the null hypothesis, indicating that the series is stationary. - The differencing appears to have stabilized the mean of the time series, making it more suitable for further time series modeling techniques. - The plot appears to be centered around zero and does not exhibit a clear trend or seasonal pattern. - Stationarity means the statistical properties of the series (like mean and variance) are constant over time. 4.6 Perform ACF &amp; PACF test to find the probable model candidates. Explain the outcome of the plots. # ACF &amp; PACF plots of differenced data to find the probable model candidates acf(bitcoin_diff, lag.max = 24, main = &quot;ACF of Differenced Bitcoin Prices&quot;) pacf(bitcoin_diff, lag.max = 24, main = &quot;PACF of Differenced Bitcoin Prices&quot;) Code explanation here Stationarity: The ACF plot of the differenced Bitcoin prices shows a significant autocorrelation at lag 1 and quickly diminishing autocorrelations at higher lags. This suggests that the first differencing has effectively made the series stationary and has successfully removed trends and seasonality 4.7 Perform EACF test to comprehensively test the possible candidate models. Mention the models that you have selected for modeling (select at least 3 models). # Perform EACF test (Enhanced ACF test) # Install and load eacf package if necessary # install.packages(&quot;TSA&quot;) library(TSA) ## Registered S3 methods overwritten by &#39;TSA&#39;: ## method from ## fitted.Arima forecast ## plot.Arima forecast ## ## Attaching package: &#39;TSA&#39; ## The following object is masked from &#39;package:readr&#39;: ## ## spec ## The following objects are masked from &#39;package:stats&#39;: ## ## acf, arima ## The following object is masked from &#39;package:utils&#39;: ## ## tar eacf(bitcoin_diff,ar.max = 3,ma.max = 3) ## AR/MA ## 0 1 2 3 ## 0 o o o o ## 1 x x o o ## 2 o x o o ## 3 x o x o Code explanation here The EACF (Extended Autocorrelation Function) table is used in the identification of ARMA (AutoRegressive Moving Average) models. Based on the EACF, we select the ARIMA parameters of models (0,1,1), (0,1,2), (1,1,2), (2,1,2) This is just one method for model identification. we will use other diagnostics and criteria, such as AIC (Akaike Information Criterion) or BIC (Bayesian Information Criterion), to confirm the best model fit. 4.8 Estimate the ARIMA parameters by creating the above selected models. Perform coeftest on each model. Explain the outcome from the level of significance. #ARIMA(0, 1, 1) model_011 &lt;- Arima(bitcoin_diff, order = c(0, 1, 1)) coeftest(model_011) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ma1 -1.000000 0.028907 -34.594 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #ARIMA(0, 1, 2) model_012 &lt;- Arima(bitcoin_diff, order = c(0, 1, 2)) coeftest(model_012) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ma1 -0.735344 0.099068 -7.4227 1.148e-13 *** ## ma2 -0.264656 0.095704 -2.7654 0.005686 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #ARIMA(1, 1, 2) model_112 &lt;- Arima(bitcoin_diff, order = c(1, 1, 2)) coeftest(model_112) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 -0.11182 0.23669 -0.4724 0.636606 ## ma1 -0.64103 0.21104 -3.0374 0.002386 ** ## ma2 -0.35894 0.20954 -1.7130 0.086706 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #ARIMA(2, 1, 2) model_212 &lt;- Arima(bitcoin_diff, order = c(2, 1, 2)) coeftest(model_212) ## ## z test of coefficients: ## ## Estimate Std. Error z value Pr(&gt;|z|) ## ar1 0.292715 0.372707 0.7854 0.432234 ## ar2 -0.207007 0.118281 -1.7501 0.080095 . ## ma1 -1.057770 0.378124 -2.7974 0.005151 ** ## ma2 0.057778 0.377031 0.1532 0.878206 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ARIMA Model Significance Summary: - ARIMA(0, 1, 1): The MA(1) term is highly significant (p-value &lt; 2.2e-16), indicating a strong influence on the model. - ARIMA(0, 1, 2): Both MA(1) and MA(2) terms are significant (p-values 1.148e-13 and 0.005686, respectively), suggesting the inclusion of both terms improves the model fit. - ARIMA(1, 1, 2): The MA(1) term is significant (p-value = 0.002386), while AR(1) and MA(2) terms are not significant, implying a moderate model fit. - ARIMA(2, 1, 2): The MA(1) term is significant (p-value = 0.005151), but AR(1), AR(2), and MA(2) terms are not, indicating a less reliable model. 4.9 Evaluate the models through AIC &amp; BIC tests. # Extract AIC and BIC values aic_values &lt;- c(AIC(model_011), AIC(model_012), AIC(model_112),AIC(model_212)) bic_values &lt;- c(BIC(model_011), BIC(model_012), BIC(model_112), BIC(model_212)) # Create a data frame print_all_model_AIC_BIC &lt;- data.frame( Model = c(&quot;model_011&quot;, &quot;model_012&quot;, &quot;model_112&quot;, &quot;model_212&quot;), AIC = aic_values, BIC = bic_values ) print(print_all_model_AIC_BIC) ## Model AIC BIC ## 1 model_011 2070.910 2076.218 ## 2 model_012 2066.781 2074.743 ## 3 model_112 2068.555 2079.171 ## 4 model_212 2068.457 2081.727 Code explanation here - Based on AIC, Model 2 (ARIMA(2, 1, 2)) is the best model, as it has the lowest AIC value, suggesting a good fit to the data. - Based on BIC, Model 3 (ARIMA(0, 1, 1)) is the best model, as it has the lowest BIC value, indicating it strikes the best balance between fit and simplicity. - Thus, Model 2 is preferable for a better fit, but if simplicity and avoiding overfitting are more important, Model 3 would be the better choice. 4.10 From outcome of above two steps select best two models. Explain why you have chosen those two models. # Select best two models based on AIC and BIC #best_model1 &lt;- model2 #best_model2 &lt;- model3 Code explanation here 4.11 Assess the chosen two models through accuracy test. # Assess the chosen two models through accuracy test model_012 = Arima(bitcoin_diff, order = c(0, 1, 2)) model_212 = Arima(bitcoin_diff, order = c(2, 1, 2)) accuracy_012 &lt;- accuracy(model_012) accuracy_212 &lt;- accuracy(model_212) df_models &lt;- data.frame( rbind(accuracy_012, accuracy_212) ) colnames(df_models) &lt;- c(&quot;ME&quot;, &quot;RMSE&quot;, &quot;MAE&quot;, &quot;MPE&quot;, &quot;MAPE&quot;, &quot;MASE&quot;, &quot;ACF1&quot;) rownames(df_models) &lt;- c(&quot;ARIMA(0,1,2)&quot;, &quot;ARIMA(2,1,2)&quot;) kable(df_models, digits = 2, formats=&quot;html&quot;, row.names = TRUE) %&gt;% kable_styling(full_width = F, font_size = 12, position = &quot;center&quot;) ME RMSE MAE MPE MAPE MASE ACF1 ARIMA(0,1,2) 119.83 4312.32 2490.54 -133.07 345.53 0.60 -0.03 ARIMA(2,1,2) 130.27 4255.79 2424.69 -135.03 343.44 0.59 -0.01 Code explanation here 4.11.1 Perform residual analysis of the two models and create line &amp; scatter plot of the residuals. Explain the outcome. # Extract residuals from the models residuals_012 &lt;- residuals(model_012) residuals_212 &lt;- residuals(model_212) # Set up the plotting area to have 2 rows and 2 columns for 4 plots par(mfrow = c(1, 1)) # Plot 1: Time series plot of standardized residuals for Model 012 (line plot) plot(residuals_012, xlab = &quot;Year Index&quot;, ylab = &quot;Residuals&quot;, main = &quot;Time series plot of standardized residuals - Model 012&quot;, type = &quot;l&quot;, col = &quot;blue&quot;) abline(h = 0, col = &quot;red&quot;, lty = 2) # Plot 2: Scatter plot of standardized residuals for Model 012 plot(residuals_012, xlab = &quot;Year Index&quot;, ylab = &quot;Residuals&quot;, main = &quot;Scatter plot of standardized residuals - Model 012&quot;, pch = 16, col = &quot;blue&quot;) abline(h = 0, col = &quot;red&quot;, lty = 2) # Plot 3: Time series plot of standardized residuals for Model 212 (line plot) plot(residuals_212, xlab = &quot;Year Index&quot;, ylab = &quot;Residuals&quot;, main = &quot;Time series plot of standardized residuals - Model 212&quot;, type = &quot;l&quot;, col = &quot;green&quot;) abline(h = 0, col = &quot;red&quot;, lty = 2) # Plot 4: Scatter plot of standardized residuals for Model 212 plot(residuals_212, xlab = &quot;Year Index&quot;, ylab = &quot;Residuals&quot;, main = &quot;Scatter plot of standardized residuals - Model 212&quot;, pch = 16, col = &quot;green&quot;) abline(h = 0, col = &quot;red&quot;, lty = 2) Code explanation here 4.12 Create a histogram plot of the residuals of the two models. Explain the outcome. # Histogram plot of the residuals ggplot() + geom_histogram(aes(x = residuals_012), binwidth = 500, color = &quot;black&quot;, fill = &quot;blue&quot;, alpha = 0.7) + labs(title = &quot;Histogram of Residuals for Best Model 012&quot;, x = &quot;Residuals&quot;, y = &quot;Frequency&quot;) + theme_minimal() ## Don&#39;t know how to automatically pick ## scale for object of type &lt;ts&gt;. ## Defaulting to continuous. ggplot() + geom_histogram(aes(x = residuals_212), binwidth = 500, color = &quot;black&quot;, fill = &quot;blue&quot;, alpha = 0.7) + labs(title = &quot;Histogram of Residuals for Best Model 212&quot;, x = &quot;Residuals&quot;, y = &quot;Frequency&quot;) + theme_minimal() ## Don&#39;t know how to automatically pick ## scale for object of type &lt;ts&gt;. ## Defaulting to continuous. Code explanation here 4.13 Create ACF &amp; PACF plots of residuals of the two models. Explain the outcome. # ACF &amp; PACF plots of residuals acf(residuals_012, main = &quot;ACF of Residuals for Best Model 012&quot;) pacf(residuals_012, main = &quot;PACF of Residuals for Best Model 012&quot;) acf(residuals_212, main = &quot;ACF of Residuals for Best Model 212&quot;) pacf(residuals_212, main = &quot;PACF of Residuals for Best Model 212&quot;) Code explanation here 4.14 Create QQ plot of residuals of the two models. Explain the outcome. # Create QQ plot of residuals qqnorm(residuals_012, main = &quot;QQ Plot of Residuals for Best Model 011&quot;) qqline(residuals_012, col = &quot;red&quot;) qqnorm(residuals_212, main = &quot;QQ Plot of Residuals for Best Model 212&quot;) qqline(residuals_212, col = &quot;red&quot;) Code explanation here 4.15 Perform Shapiro-Wilk test on residuals of the two models. Explain the outcome. # Perform Shapiro-Wilk test on residuals shapiro_test_model012 &lt;- shapiro.test(residuals_012) shapiro_test_model212 &lt;- shapiro.test(residuals_212) # Print the result of the Shapiro-Wilk test print(shapiro_test_model012) ## ## Shapiro-Wilk normality test ## ## data: residuals_012 ## W = 0.85275, p-value = 7.244e-09 print(shapiro_test_model212) ## ## Shapiro-Wilk normality test ## ## data: residuals_212 ## W = 0.84232, p-value = 2.946e-09 Code explanation here 4.16 Select the best model from the above two models using the outcome of all the above analysis. This is going to be your final model. Conclusion: While model_012 (ARIMA(0,1,2)) has the lowest AIC and BIC values, indicating it is the preferred model based on information criteria, the ARIMA(2,1,2) model has slightly better accuracy metrics. Given the trade-off between simplicity and accuracy, if model parsimony (fewer parameters) and lower information criteria are prioritized, model_012 (ARIMA(0,1,2)) would be the best fit model. However, if slightly better accuracy is prioritized and the increase in complexity is acceptable, ARIMA(2,1,2) could be considered. Overall, ARIMA(0,1,2) is a balanced choice, providing a good fit with lower AIC and BIC values. "],["forecasting.html", "Chapter 5 Forecasting 5.1 Key Insights", " Chapter 5 Forecasting # Load necessary libraries library(forecast) library(tidyverse) library(kableExtra) # Load the data BitCoin &lt;- read.csv(&quot;https://raw.githubusercontent.com/shakibed/Final_Project_Group_04/main/BTC-Monthly.csv&quot;, stringsAsFactors = FALSE) # Convert date BitCoin$Date &lt;- as.Date(BitCoin$Date) # Convert to time series object bitcoin_ts &lt;- ts(BitCoin$Close, start = c(as.numeric(format(min(BitCoin$Date), &quot;%Y&quot;)), as.numeric(format(min(BitCoin$Date), &quot;%m&quot;))), frequency = 12) 5.0.1 Explanation of the Forecast Table bitcoin_forecast_fit_model &lt;- Arima(bitcoin_ts,c(0,1,2)) forecast_next_12 &lt;- forecast(bitcoin_forecast_fit_model,h=12) kable(forecast_next_12, digits = 2, formats=&quot;html&quot;, row.names = TRUE) %&gt;% kable_styling(full_width = F, font_size = 12, position = &quot;center&quot;) Point Forecast Lo 80 Hi 80 Lo 95 Hi 95 Dec 2023 37492.11 31918.44 43065.77 28967.92 46016.29 Jan 2024 37363.86 28605.25 46122.46 23968.73 50758.98 Feb 2024 37363.86 26564.53 48163.18 20847.71 53880.00 Mar 2024 37363.86 24852.35 49875.36 18229.16 56498.55 Apr 2024 37363.86 23347.79 51379.92 15928.14 58799.57 May 2024 37363.86 21989.78 52737.93 13851.23 60876.48 Jun 2024 37363.86 20742.35 53985.36 11943.45 62784.26 Jul 2024 37363.86 19582.21 55145.50 10169.18 64558.53 Aug 2024 37363.86 18493.27 56234.44 8503.78 66223.93 Sep 2024 37363.86 17463.82 57263.89 6929.38 67798.33 Oct 2024 37363.86 16485.07 58242.64 5432.51 69295.20 Nov 2024 37363.86 15550.19 59177.52 4002.74 70724.97 The forecast table provides the projected Bitcoin prices for the next 12 months along with their confidence intervals. Here’s what each column represents: -Point Forecast: This is the predicted value of the Bitcoin price for each month. It’s the best estimate based on the ARIMA(0,1,2) model. - Lo 80 and Hi 80: These columns represent the lower and upper bounds of the 80% confidence interval. There’s an 80% chance that the actual Bitcoin price will fall within this range. - Lo 95 and Hi 95: These columns represent the lower and upper bounds of the 95% confidence interval. There’s a 95% chance that the actual Bitcoin price will fall within this range. 5.1 Key Insights Steady Price Increase: The point forecast predicts a steady increase in Bitcoin prices from approximately $36,803 in December 2023 to $37,310 in November 2024. Uncertainty Range: The prediction intervals widen over time, indicating increasing uncertainty, with 95% confidence intervals ranging from around $28,451 to $45,154 in December 2023 to $2,952 to $71,669 in November 2024. Moderate Fluctuations: The forecasts suggest moderate monthly fluctuations, with the highest forecasted point in April 2024 and the lowest in March 2024. 5.1.1 a plot of the forecasted data points of next 12 months plot(forecast_next_12, main = &quot;ARIMA(0,1,2) Model Forecast&quot;) ``` "],["conclusion.html", "Chapter 6 Conclusion 6.1 Linear Regression: 6.2 Quadratic Regression: 6.3 ARIMA:", " Chapter 6 Conclusion 6.1 Linear Regression: Simple and easy to interpret but limited in capturing complex patterns and sensitive to outliers. 6.2 Quadratic Regression: Adds flexibility for slight non-linearity but may overfit and has issues with coefficient significance. 6.3 ARIMA: Best captures trends and seasonality in time series data, offering the most accurate forecasts, albeit with greater complexity. For a balanced trade-off between model simplicity and forecasting accuracy, the ARIMA(0,1,2) model emerges as a suitable choice. However, for slightly improved accuracy, the ARIMA(2,1,2) model can be considered, accepting the trade-off of increased complexity. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
